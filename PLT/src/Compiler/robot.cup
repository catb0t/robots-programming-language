package app;

import java_cup.runtime.*;
import java.io.*;
import java.util.*;

parser code {:
	public static String  robotProgram;
	public static String  globalAssignments;
	public static boolean bDebugFlag;
	public static Yylex   scanner;

	/* stores a basic symbol table */
	public static RobotScopeManager sm;
	
	public static String temp;

        public static void main(String args[]) throws Exception {
           bDebugFlag = true;
           try {
              robotProgram = "import app.*;\nimport java.util.*;\n";
              globalAssignments = "";
              sm = new RobotScopeManager();
			  scanner = new Yylex(new BufferedReader(new FileReader(args[0])));
              new parser(scanner).debug_parse();

              // dump generated java code to file
              FileWriter fwTranslatedCode = new FileWriter(args[1], false);
              BufferedWriter bwTranslatedCode = new BufferedWriter(new FileWriter(args[1], false));
              robotProgram.replaceAll("\n", System.getProperty("line.separator"));
              bwTranslatedCode.write(robotProgram);
              bwTranslatedCode.close();

              //System.out.println("Translated Java code:\n" + robotProgram);
           } catch (Exception e) {
              System.out.println(e.getMessage());
           }
        }
        
        public void syntax_error(java_cup.runtime.Symbol current) {
    		System.out.println("*** Syntax error ***");
    		System.out.println("Line#: " + (scanner.getLineNumber() + 1));
    		System.out.println("Column#: " + scanner.getColumnNumber());
    		System.out.println("Near token: " + scanner.lastToken());
    		System.out.println("Terminal/Non-terminal #: " + current + "\n");
    		System.exit(0);
  		}
  		
  		public void custom_error(String errMsg) {
            System.out.println("*** Syntax error ***\n" + errMsg);
            System.out.println("Line#: " + (scanner.getLineNumber() + 1));
    		System.out.println("Column#: " + scanner.getColumnNumber());
    		System.exit(0);
  		}
:}
/* Terminals (tokens returned by the scanner) */
terminal         SEMI, PLUS, MINUS, TIMES, DIVIDE, LPAREN, RPAREN;
terminal         THINK, END, SAY, NEWLINE, EQUALS, IS, INSTRUCTION, WITH;
terminal         GIVES, MEANS, TRUE, FALSE, OR, AND, NOT;
terminal         MIN_HASH, MAX_HASH, NOTHING_NOT, NOWHERE_AT, OF, SELF;
terminal         IF, THEN, ELSE, DONE;
terminal         REPEAT, IN, EACH;
terminal         ROLLOVER;
terminal         NOTHING_RES;
terminal Integer NUMBER;
terminal String  NUMBER_EXPRESSION;
terminal String  NUMBER_PERCENTAGE;
terminal String  ANYTHING, INT_IDX;
terminal         IS_LOWER_THAN, IS_STRICTLY_LOWER_THAN, IS_DIFFERENT_FROM;
terminal         IS_STRICTLY_GREATER_THAN, IS_GREATER_THAN, IS_EQUAL_TO;
terminal String  NUMBER_NAME_IDX;
terminal String  FUNCTION_NAME;
terminal RobotVar VARIABLE;
terminal String  INTEGER;
terminal         TIMES_REPEAT;

/* Non-terminals */
non terminal         expr_list, expr_part;
non terminal Integer expr;
non terminal String  statement, entry, variable_name, program, block;
non terminal         optnl, assign_op;
non terminal String  function, functions, variable_name_local;
non terminal String  boolean_final, declaration, boolean_expression, boolean_component;
non terminal String  any_expr;
non terminal String  arithmetic_operator, constant_value;
non terminal String  call, field_access, local_declaration;
//non terminal String  field_name;
non terminal String  conditional, else_statement;
non terminal String  argument, arguments, arguments_act, function_call;
non terminal String  comparison_operator, index;
non terminal String  assignment;
non terminal String  loop;
non terminal Expression arithmetic_expression;

/* Precedences: Follow Java conventions */

precedence left  OR;
precedence left  AND;

precedence left IS_DIFFERENT_FROM, IS_EQUAL_TO;

/* Do not split this line */
precedence nonassoc IS_STRICTLY_GREATER_THAN, IS_GREATER_THAN, IS_LOWER_THAN, IS_STRICTLY_LOWER_THAN;

precedence left PLUS, MINUS, ROLLOVER;
precedence left TIMES, DIVIDE;

precedence right OF;

precedence right NOT;

precedence left LPAREN, RPAREN;


/* The Grammar */
program         ::= optnl declaration:dcls
                    optnl entry:ent
                    optnl functions:funcs
                    optnl
                    {:
                       RESULT =  "\npublic class RobotCompiled extends Robot {\n\n";
                       RESULT += dcls + ent + funcs;

                       if(parser.globalAssignments.compareTo("") != 0) {
                          //Constructor, if you please
                       	  RESULT += "\n\n\tpublic RobotCompiled() {\n\t";
                       	  RESULT += parser.globalAssignments + "\t}\n";
                       }
                       RESULT += "\n}\n";

                       parser.robotProgram += RESULT;
                    :}
;

declaration     ::= /*variable_name:vn*/ VARIABLE:v NEWLINE 
                    optnl declaration:dcl
                    {:
                       //RESULT = vn + ";\n" + dcl;
                       parser.temp = parser.sm.declareIfNecessary(v);
                       if(parser.temp.compareTo("") != 0) {
                         RESULT = parser.temp + v.name();
                       } else {
                         // It is an error to declare the same name twice in global scope
                         System.err.println("Duplicate declaration: " + v.name() + "\n");
                         System.exit(0);
                       }
                    :}
                 /*|
                    variable_name:vn assign_op value:val NEWLINE 
                    optnl declaration:dcl
                    {: 
                       RESULT = vn + " = " + val + ";\n" + dcl;
                    :}*/
                 |
                    /*variable_name:vn*/ VARIABLE:v assign_op any_expr:ex NEWLINE
                    optnl declaration:dcl
                    {:
                       //RESULT = parser.sm.declareIfNecessary(v) + v.name();
                       parser.temp = parser.sm.declareIfNecessary(v);
                       String t = parser.temp + v.name() + " = " + ex + ";\n";
                       if(parser.temp.compareTo("") != 0) {
                          RESULT = t + dcl;
                       } else {
                          RESULT = dcl;
                          parser.globalAssignments += "\t\tthis." + t;
                       }
                    :}
                 |
                    field_access:fa assign_op any_expr:ex NEWLINE
                    optnl declaration:dcl
                    {:
                       //RESULT = fa + " = " + ex + ";\n" + dcl;
                       RESULT = dcl;
                       parser.globalAssignments += fa + " = " + ex + ";\n";
                    :}
                 |
                    /* empty */
                    {:
                       RESULT = "";
                    :}
;

//TODO: What happens if base_value is not already declared?  Should we create a new instance?
field_access    ::= VARIABLE:v OF arithmetic_expression:ae
                    {:
                       RESULT = ae.declarations.toString() + ae.javaCode.toString() + "." + v.name();
                    :}
                |   
                    function_call:fc OF arithmetic_expression:ae
                    {:
                       RESULT = ae.declarations.toString() + ae.javaCode.toString() + "." + fc;
                    :}
                |   
                    index:idx OF arithmetic_expression:ae
                    {:
                       RESULT = ae.declarations.toString() + ae.javaCode.toString() + ".get(" + idx + ")";
                    :}
                /*|   
                    variable_name:vn
                    {:
                       RESULT = vn;
                    :} 
                |   
                    SELF
                    {:
                       RESULT = "this";
                    :}*/
;

index           ::=  NUMBER_NAME_IDX:nnidx
                     {: RESULT = nnidx.substring(0, nnidx.length()-3);:}
                |
                     INT_IDX:nidx
                     {: RESULT = nidx.substring(0, nidx.length()-2) + "f";  :}
;
/*
field_name      ::=  VARIABLE:v
                     {:
                       RESULT = v.name();
                     :}
                |
                     function_call:fc
                     {:
                        RESULT = fc;
                     :}
;
*/
// TODO: We don't need to call isDeclared, it's already being called in declare variable
// See local_variable to see shorter usage
// Also, I was thinking that we can add a Java Enum to enumerate our types and enter
// associated information like the corresponding Java type, postfix, etc.  Would be much
// cleaner than typing those things every time, I think
variable_name   ::= VARIABLE:v
                    {:
                       RESULT = parser.sm.declareIfNecessary(v) + v.name(); 
                    :}
;

functions       ::=   function:fn optnl
                      functions:fns          {: RESULT = fn + fns; :}
                |
                      /* empty */            {: RESULT = ""; :}
;

function        ::=   INSTRUCTION FUNCTION_NAME:fn {: parser.sm.increaseLevel(); :}
                      WITH arguments:arg MEANS NEWLINE optnl
                      block:b optnl
                      GIVES VARIABLE:v NEWLINE
                      {:
                         // remove the final ,<space> : (arg1, arg2, ,<space>)
                         arg = arg.trim();
                         if (arg.endsWith(",")) {
                         	arg = arg.substring(0, arg.length() - 1);
                         }
                         RESULT = "\n\tpublic " + v.javaType() + " " + fn + "(" + arg + ") {\n";
                         RESULT += "\n" + b;
                         if (v.type() != RobotType.NOTHING) {
                            RESULT += parser.sm.indent() + "return " + v.name() + ";\n";
                         }
                         RESULT += "\t}";
                         parser.sm.decreaseLevel();
                      :}
;

//TODO: Arguments probably should use their own production rather than variable_name_local
//      variable_name_local gets declareIfNecessary, but arguments should ALWAYS have a declaration in front of them
arguments        ::=   variable_name_local:arg arguments:args 
                       {:
                          RESULT = arg + ", " + args;
                       :}
                |
                       /* empty */
                       {:
                          RESULT = "";
                       :}                      
;

variable_name_local  ::=  VARIABLE:v
                          {:
                             RESULT = parser.sm.declareIfNecessary(v) + v.name();
                          :}
;
/*
base_value      ::=   field_name:fn            {:   RESULT = fn;     :}
                |
                      constant_value:cv        {:   RESULT = cv;     :}
                |
                      function_call:fc         {:   RESULT = fc;     :}
                |
                      field_access:fa          {:   RESULT = fa;     :}
                |
                      SELF                     {:   RESULT = "this"; :}
                |
                      arithmetic_expression:ae {:   RESULT = ae;     :}
;
*/
any_expr        ::=   boolean_expression:be    {:   RESULT = be; :}
                /*|
                      arithmetic_expression:ae {:   RESULT = ae; :}*/
;

arithmetic_expression   ::=   arithmetic_expression:ae1 arithmetic_operator:ao arithmetic_expression:ae2
                              {:
                                 RESULT = new Expression();
                                 // Call the appropriate Java function
                                 RESULT.declarations.append(ae1.declarations);
                                 RESULT.declarations.append(ae2.declarations);

                                 if(ao == "%") { //ROLLOVER
                                     RESULT.javaCode.append("Func.rollover(").append(ae1.javaCode).append(", ").append(ae2.javaCode).append(")");
                                 } else if(ao == "+") {
                                     RESULT.javaCode.append("Func.add(").append(ae1.javaCode).append(", ").append(ae2.javaCode).append(")");
                                 } else if(ao == "*") {
                                     RESULT.javaCode.append("Func.times(").append(ae1.javaCode).append(", ").append(ae2.javaCode).append(")");
                                 } else {
                                     RESULT.javaCode.append(ae1.javaCode).append(ao).append(ae2.javaCode);
                                 }
                              :}
                        |
                              LPAREN arithmetic_expression:ae RPAREN
                              {:
                                 RESULT = new Expression();
                                 RESULT.declarations = ae.declarations;
                                 RESULT.javaCode.append("( ").append(ae.javaCode).append(" )");
                              :}
                        |
                              NUMBER_EXPRESSION:ne
                              {:
                                 RESULT = new Expression("new Float(" + ne + ")");
                              :}
                        |
                              NUMBER_PERCENTAGE:pe
                              {:
                                 RESULT = new Expression("new Percentage(" + pe.substring(0, pe.length() - 1) + ")");
                              :}
                        |     
                              VARIABLE:v
                              {:
                                 RESULT = new Expression(v.name());
                                 
                                 parser.temp = parser.sm.declareIfNecessary(v);
                                 if(!parser.temp.equals("")) {
                                 	 parser.temp += v.name() + " = new " + v.javaType() + "(";
                                         //TODO: put this logic into RobotVar
                                         if (v.isList()) parser.temp += v.type().javaType() + ".class";
                                         parser.temp += ");\n" + parser.sm.indent();
                                         RESULT.declarations.append(parser.temp);
                                 }
                                 
                              :}
                        |
                              function_call:fc
                              {:
                                 RESULT = new Expression(fc);
                              :}
                        |
                              constant_value:cv        {:   RESULT = new Expression(cv);     :}
                        |
                              field_access:fa          {:   RESULT = new Expression(fa);     :}
                        |
                              SELF                     {:   RESULT = new Expression("this"); :}
;

arithmetic_operator     ::=   PLUS     {: RESULT = "+";   :}
                        |     MINUS    {: RESULT = " - "; :}
                        |     TIMES    {: RESULT = "*";   :}
                        |     DIVIDE   {: RESULT = " / "; :}
                        |     ROLLOVER {: RESULT = "%";   :}
;

boolean_expression      ::=   boolean_expression:be1 OR boolean_expression:be2
                              {:   RESULT = be1 + " || " + be2; :}
                        |     
                              boolean_expression:be1 AND boolean_expression:be2
                              {:   RESULT = be1 + " && " + be2; :}
                        |     
                              NOT boolean_expression:be
                              {:   RESULT = "!" + be;           :}
                        |     
                              LPAREN boolean_expression:be RPAREN
                              {:   RESULT = "( " + be + " )";   :}
                        |     
                              boolean_final:bf
                              {:   RESULT = bf;                 :}
                        |
                              boolean_component:bec
                              {:  RESULT = bec;  :}
                        |
                              boolean_component:bec1 IS_EQUAL_TO
                              boolean_component:bec2
                              {:  RESULT = bec1 + ".equals(" + bec2 + ")";  :}
                        |
                              boolean_component:bec1 IS_DIFFERENT_FROM
                              boolean_component:bec2
                              {:  RESULT = "!" + bec1 + ".equals(" + bec2 + ")";  :}
                        |
                              boolean_component:bec1 comparison_operator:co
                              boolean_component:bec2
                              {:  RESULT = bec1 + co + bec2;  :}
;

boolean_component       ::=   arithmetic_expression:ae {: RESULT = ae.javaCode.toString(); :}
;
                      
comparison_operator     ::=   IS_LOWER_THAN
                              {: RESULT = "<="; :}
                        |     
                              IS_STRICTLY_LOWER_THAN
                              {: RESULT = "<"; :}
                        |     
                              IS_STRICTLY_GREATER_THAN
                              {: RESULT = ">"; :}
                        |
                              IS_GREATER_THAN
                              {: RESULT = ">="; :}
;

boolean_final           ::=   TRUE  {:   RESULT = "true";   :}
                        |     FALSE {:   RESULT = "false";  :}
;

assign_op               ::=   EQUALS
                        |     IS
;

entry                   ::=   THINK {: parser.sm.increaseLevel(); :} NEWLINE
                              optnl
                              block:b
                              optnl
                              END
                              {:
                                 RESULT =  "\n";
                                 RESULT += "\tpublic void think() {\n";
                                 RESULT += "\n";
                                 RESULT += b;
                                 RESULT += "\n";
                                 RESULT += "\t}\n";
                                 RESULT += "\n";
                                 parser.sm.decreaseLevel();
                              :}
;

constant_value          ::=   MAX_HASH          {: RESULT = "Float.MAX_VALUE";  :}
                        |     MIN_HASH		{: RESULT = "Float.MIN_VALUE";  :}
                        |     NOTHING_NOT	{: RESULT = "new Enemy()";      :}
                        |     NOWHERE_AT	{: RESULT = "new Location()";   :}
                        |     NOTHING_RES       {: RESULT = "new Resource()";   :}
;

optnl                   ::=   optnl NEWLINE
                        |
                              /* empty */
;

statement               ::=   call:cl                {: RESULT = cl   + ";"; :}
                        |     local_declaration:ldcl {: RESULT = ldcl + ";"; :}
                        |     conditional:cond       {: RESULT = cond;       :}
                        |     assignment:ass         {: RESULT = ass  + ";"; :}
                        |     loop:l                 {: RESULT = l;          :}
;

block                   ::=   statement:s {: RESULT = parser.sm.indent() + s + "\n"; :}
                              optnl
                              block:b     {: RESULT += b; :}
                        |
                              /* empty */
                              {: RESULT = ""; :}
;


assignment              ::=   /*variable_name_local:vnl*/ VARIABLE:v assign_op any_expr:ex NEWLINE
                              {:
                                 //RESULT = vnl + " = " + ex;
                                 RESULT = parser.sm.declareIfNecessary(v) + v.name();
                              	 RESULT += " = " + ex;
                              :}
                        |
                              field_access:fa assign_op any_expr:ex NEWLINE
                              {: 
                                 RESULT = fa + " = " + ex;
                              :}
;

conditional             ::=   IF boolean_expression:be THEN 
                              {:
                                 RESULT = "\n" + parser.sm.indent() + "if (" + be + ") {\n";
                                 parser.sm.increaseLevel();
                              :} NEWLINE
                              optnl
                              block:b
                              optnl
                              else_statement:es
                              optnl 
                              DONE NEWLINE
                              {:
                                 parser.sm.decreaseLevel();
                                 RESULT += b;
                                 RESULT += es;
                                 RESULT += parser.sm.indent() + "}\n"; 
                              :}
;

else_statement          ::=   ELSE
                              {:
                                 parser.sm.decreaseLevel();
                                 RESULT =  parser.sm.indent() + "} else {\n";
                                 parser.sm.increaseLevel();
                              :}
                              NEWLINE
                              optnl
                              block:b
                              {:
                                 RESULT += b;
                              :}
                        |
                              /* empty */
                              {: RESULT = ""; :}
;

loop                    ::=   REPEAT WITH EACH VARIABLE:item IN VARIABLE:list 
                              {:
                                 RESULT = "\n" + parser.sm.indent() + "for (" + item.javaType() + " " + item.name() + " : " + list.name() + ") {\n\n";
                                 parser.sm.increaseLevel();
                              :} NEWLINE
                              optnl
                              block:b
                              optnl
                              DONE NEWLINE
                              {:
                                 parser.sm.decreaseLevel();
                                 RESULT += b;
                                 RESULT += "\n" + parser.sm.indent() + "}\n";
                              :}
                         |
                              REPEAT NUMBER_EXPRESSION:num TIMES_REPEAT NEWLINE
                              {:
                              	 Float __tmpNum = new Float(num);
                              	 if(__tmpNum.intValue() < 0) {
                              	 	parser.custom_error(new String("Repeat times loop must have a positive argument"));
                              	 }

                                 RESULT = "\n" + parser.sm.indent() + "for(int __temp = 0; __temp < " + __tmpNum.intValue() + "; __temp++) {\n\n";
                                 parser.sm.increaseLevel();
                              :}
                              optnl
                              block:b
                              optnl
                              DONE NEWLINE
                              {:
                                 parser.sm.decreaseLevel();
                                 RESULT += b;
                                 RESULT += "\n" + parser.sm.indent() + "}\n";
                              :}
;

function_call           ::=   FUNCTION_NAME:fn arguments_act:args
                              {:
                                 // remove the final ,<space> : (arg1, arg2,<space>)
                                 args = args.trim();
                                 if (args.endsWith(",")) {
                         	    args = args.substring(0, args.length() - 1);
                                 }
                                 RESULT = fn + "(" + args + ")";
                              :}
;

arguments_act           ::=   any_expr:arg arguments_act:args
                              {:
                                 RESULT = arg + ", " + args;
                              :}

                        |     
                              /* empty */
                              {:
                                 RESULT = "";
                              :}
;

local_declaration       ::=   /*variable_name_local:vnl*/ VARIABLE:v NEWLINE 
                              {:
                                 //RESULT = vnl /* + dcl*/;
                                 parser.temp = parser.sm.declareIfNecessary(v);
                                 RESULT = parser.temp + v.name();
                                 if(!parser.temp.equals("")) {
                                 	 RESULT += " = new " + v.javaType() + "()";
                                 }
                              :}
                        /*|
                              variable_name_local:vnl assign_op value:val NEWLINE
                              {:
                                 RESULT = "\t\t" + vnl + " = " + val + ";\n";
                              :}
                        |
                              field_access:fa assign_op value:val NEWLINE
                              {:
                                 RESULT = "\t\t" + fa + " = " + val + ";\n";
                              :}*/
;

call                    ::=   SAY ANYTHING:a NEWLINE
                              {:
                                 RESULT = "System.out.println(\"" + a + "\")";
                              :}
                        |
                              function_call:fc
                              {:
                                 RESULT = fc;
                              :}
;

expr_list               ::=   expr_list expr_part 
                        |     expr_part
;

expr_part               ::=   expr:e
                              {:
                                 System.out.println(" = "+e+";");
                              :}
                              SEMI
;

expr                    ::=   NUMBER:n               {: RESULT=n;                                        :}
                        |     expr:l PLUS expr:r     {: RESULT=new Integer(l.intValue() + r.intValue()); :}
                        |     expr:l TIMES expr:r    {: RESULT=new Integer(l.intValue() * r.intValue()); :}
                        |     LPAREN expr:e RPAREN   {: RESULT=e;                                        :}
;
