package Robot;

import java_cup.runtime.*;
import java.io.*;
import java.util.*;

/* value   ::= variable_name
         | base_value
         | boolean_expression
         | arithmetic_expression
         | constant_expression of variable_name
         | my constant_expression
         | constant_value */

parser code {:
	public static String  robotProgram;
	public static String  globalDeclarations;
	public static boolean bDebugFlag;
	/* stores a basic symbol table */
	public static HashMap<String, String> variableMap;
	
	public static String temp;
	
	/* code related to symbol table: we have a very basic one coz java
	 is supposed to take care of the rest */
	public static boolean isNameDeclared(String name) {
	  return variableMap.containsKey(name);
	}
	
	public static boolean isDeclared(String name, String type) {
      String str = (String) variableMap.get(name);

      if (str != null && str.equals(type))
         return true;
      return false;
   }
   
   public static boolean declareVariable(String name, String type) {
      if (!isDeclared(name, type)) {
         variableMap.put(name, type);
         return true;
      }
      return false;
   }

   public static void main(String args[]) throws Exception {
      bDebugFlag = true;
      try {
         robotProgram = "package Think;\n";
         globalDeclarations = "";
         variableMap = new HashMap<String, String>();
         new parser(new Yylex(new BufferedReader(new FileReader(args[0])))).parse();
         
         // dump generated java code to file
         FileWriter fwTranslatedCode = new FileWriter(args[1], false);
         BufferedWriter bwTranslatedCode = new BufferedWriter(new FileWriter(args[1], false));
         robotProgram.replaceAll("\n", System.getProperty("line.separator"));
         bwTranslatedCode.write(robotProgram);
         bwTranslatedCode.close();

         //System.out.println("Translated Java code:\n" + robotProgram);
      } catch (Exception e) {
         System.out.println(e.getMessage());
      }
   }
:}

/* Terminals (tokens returned by the scanner) */
terminal         SEMI, PLUS, MINUS, TIMES, DIVIDE, LPAREN, RPAREN;
terminal         THINK, END, SAY, NEWLINE, EQUALS, IS, INSTRUCTION, WITH;
terminal         GIVES, NOTHING, MEANS, TRUE, FALSE, OR, AND, NOT;
terminal         MIN_HASH, MAX_HASH, NOTHING_NOT, NOWHERE_AT, OF, SELF;
terminal Integer NUMBER;
terminal Double  NUMBER_EXPRESSION;
terminal String  NUMBER_PERCENTAGE;
terminal String  ANYTHING, INT_IDX;
terminal String  NUMBER_NAME, BOOLEAN_NAME, PERCENTAGE_NAME, LOCATION_NAME;
terminal String  ENEMY_NAME, RESOURCE_NAME, LIST_NAME, FUNCTION_NAME;

/* Non-terminals */
non terminal         expr_list, expr_part;
non terminal Integer expr;
non terminal String  statement, entry, variable_name, program, return_value;
non terminal         optnl, assign_op;
non terminal String  function_name, function, functions, variable_name_local;
non terminal String  boolean_final, base_value, declaration, boolean_expression;
non terminal String  arithmetic_expression, arithmetic_operator, constant_value;
non terminal String  value, call, field_access, local_declaration;
non terminal String  field_name;
non terminal String  argument, arguments, arguments_act, function_call;

/* Precedences */
precedence right OF;

precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;

precedence left  OR;
precedence left  AND;
precedence right NOT;


/* The Grammar */
program         ::= optnl declaration:dcls
                    optnl entry:ent
                    optnl functions:funcs
                    optnl
                    {:
                       RESULT =  "\npublic class Robot {\n";
                       RESULT += dcls + ent + funcs;
                       RESULT += "\n}";
                       parser.robotProgram += RESULT;
                    :}
;

declaration     ::= variable_name:vn NEWLINE 
                    optnl declaration:dcl
                    {:
                       RESULT = vn + ";\n" + dcl;
                    :}
                 /*|
                    variable_name:vn assign_op value:val NEWLINE 
                    optnl declaration:dcl
                    {: 
                       RESULT = vn + " = " + val + ";\n" + dcl;
                    :}*/
                 |
                    field_access:fa assign_op value:val NEWLINE
                    optnl declaration:dcl
                    {:
                       RESULT = fa + " = " + val + ";\n" + dcl;
                    :}
                 |
                    /* empty */
                    {:
                       RESULT = "";
                    :}
;

field_access    ::= field_name:fn OF field_access:fa
                    {:
                       RESULT = fa + "." + fn;
                    :}
                |   
                    INT_IDX:idx OF field_access:fa
                    {:
                       RESULT = fa + "[" + idx.substring(0, idx.length() - 2) + "]";
                    :}
                |   
                    variable_name:vn
                    {:
                       RESULT = vn;
                    :}
                |   
                    SELF
                    {:
                       RESULT = "this";
                    :}
;

field_name      ::=  NUMBER_NAME:nn
                     {:
                       RESULT = nn.substring(0, nn.length() - 1);
                     :}
                 |
                    LIST_NAME:ln
                    {:
                       RESULT = ln.substring(0, ln.length() - 3);
                    :}
                |
                    BOOLEAN_NAME:bn
                    {:
                       RESULT = bn.substring(0, bn.length() - 1);
                    :}
                |
                    PERCENTAGE_NAME:pn
                    {:
                       RESULT = pn.substring(0, pn.length() - 1);
                    :}

                |
                    LOCATION_NAME:ln
                    {:
                       RESULT = ln.substring(0, ln.length() - 1);
                    :}
                |
                    ENEMY_NAME:en
                    {:
                       RESULT = en.substring(0, en.length() - 1);
                    :}
                |
                    RESOURCE_NAME:rn
                    {:
                       RESULT = rn.substring(0, rn.length() - 1);
                    :}
;

variable_name   ::= NUMBER_NAME:nn
                    {:
                       parser.temp = nn.substring(0, nn.length() - 1);
                       if (!parser.isDeclared(parser.temp, "#")) {
                          RESULT = "\tpublic double " + parser.temp;
                          parser.declareVariable(parser.temp, "#");
                       } else {
                          RESULT = parser.temp;
                       }
                    :}
                 |
                    LIST_NAME:ln
                    {:
                       parser.temp = ln.substring(0, ln.length() - 3);
                       if (!parser.isDeclared(parser.temp, "#")) {
                          RESULT = "\tpublic List " + parser.temp;
                          parser.declareVariable(parser.temp, "...");
                       } else {
                          RESULT = parser.temp;
                       }
                    :}
                |
                    BOOLEAN_NAME:bn
                    {:
                       parser.temp = bn.substring(0, bn.length() - 1);
                       if (!parser.isDeclared(parser.temp, "?")) {
                          RESULT = "\tpublic boolean " + parser.temp;
                          parser.declareVariable(parser.temp, "?");
                       } else {
                          RESULT = parser.temp;
                       }
                    :}
                |
                    PERCENTAGE_NAME:pn
                    {:
                       parser.temp = pn.substring(0, pn.length() - 1);
                       if (!parser.isDeclared(parser.temp, "#")) {
                          RESULT = "\tpublic Percentage " + parser.temp;
                          parser.declareVariable(parser.temp, "%");
                       } else {
                          RESULT = parser.temp;
                       }
                    :}

                |
                    LOCATION_NAME:ln
                    {:
                       parser.temp = ln.substring(0, ln.length() - 1);
                       if (!parser.isDeclared(parser.temp, "@")) {
                          RESULT = "\tpublic Location " + parser.temp;
                          parser.declareVariable(parser.temp, "@");
                       } else {
                          RESULT = parser.temp;
                       }
                    :}
                |
                    ENEMY_NAME:en
                    {:
                       parser.temp = en.substring(0, en.length() - 1);
                       if (!parser.isDeclared(parser.temp, "!")) {
                          RESULT = "\tpublic Enemy " + parser.temp;
                          parser.declareVariable(parser.temp, "!");
                       } else {
                          RESULT = parser.temp;
                       }
                    :}
                |
                    RESOURCE_NAME:rn
                    {:
                       parser.temp = rn.substring(0, rn.length() - 1);
                       if (!parser.isDeclared(parser.temp, "$")) {
                          RESULT = "\tpublic Resource " + parser.temp;
                          parser.declareVariable(parser.temp, "$");
                       } else {
                          RESULT = parser.temp;
                       }
                    :}
;

functions       ::=   function:fn optnl
                      functions:fns          {: RESULT = fn + fns; :}
                |
                      /* empty */            {: RESULT = ""; :}
;

function        ::=   INSTRUCTION function_name:fn WITH arguments:arg MEANS NEWLINE optnl
                      /*local_declaration:ldcl optnl*/
                      statement:stat optnl
                      GIVES return_value:rv NEWLINE
                      {:
                         // remove the final ,<space> : (arg1, arg2, ,<space>)
                         arg = arg.trim();
                         if(arg.endsWith(",")) {
                         	arg = arg.substring(0, arg.length() - 1);
                         }
                         RESULT = "\n\tpublic static " + rv + " " + fn + "(" + arg + ")";
                         RESULT += " {\n" /*+ ldcl*/ + "\n" + stat + "\n\t}";
                      :}
;

function_name   ::=   FUNCTION_NAME:fn       {: RESULT = fn;   :}
;

return_value    ::=   value:val              {: RESULT = val;    :}
                |
                      NOTHING                {: RESULT = "void"; :}
;

arguments        ::=   variable_name_local:arg arguments:args 
                       {:
                          RESULT = arg + ", " + args;
                       :}
                |
                       /* empty */
                       {:
                          RESULT = "";
                       :}
                      
;

variable_name_local  ::=  
                    NUMBER_NAME:nn
                    {:
                       RESULT = "double " + nn.substring(0, nn.length() - 1);
                    :}
                 |
                    LIST_NAME:ln
                    {:
                       RESULT = "List " + ln.substring(0, ln.length() - 3);
                    :}
                |
                    BOOLEAN_NAME:bn
                    {:
                       RESULT = "boolean " + bn.substring(0, bn.length() - 1);
                    :}
                |
                    PERCENTAGE_NAME:pn
                    {:
                       RESULT = "Percentage " + pn.substring(0, pn.length() - 1);
                    :}

                |
                    LOCATION_NAME:ln
                    {:
                       RESULT = "Location " + ln.substring(0, ln.length() - 1);
                    :}
                |
                    ENEMY_NAME:en
                    {:
                       RESULT = "Enemy " + en.substring(0, en.length() - 1);
                    :}
                |
                    RESOURCE_NAME:rn
                    {:
                       RESULT = "Resource " + rn.substring(0, rn.length() - 1);
                    :}
;

value           ::=   variable_name:vn       {:   RESULT = vn; :}
                |
                      base_value:bv          {:   RESULT = bv; :}
                |
                      constant_value:cv      {:   RESULT = cv; :}
;

base_value      ::=   boolean_expression:be    {:   RESULT = be; :}
                |
                      arithmetic_expression:ae {:   RESULT = ae; :}
;

arithmetic_expression   ::=   arithmetic_expression:ae1 arithmetic_operator:ao arithmetic_expression:ae2
                              {:
                                 RESULT = ae1 + ao + ae2;
                              :}
                        |
                              LPAREN arithmetic_expression:ae RPAREN
                              {:
                                 RESULT = "( " + ae + " )";
                              :}
                        |
                              NUMBER_EXPRESSION:ne
                              {:
                                 RESULT = ne.toString();
                              :}
                        |
                              NUMBER_PERCENTAGE:pe
                              {:
                                 RESULT = "new Percentage(" + pe.substring(0, pe.length() - 1) + ")";
                              :}
;

arithmetic_operator     ::=   PLUS     {: RESULT = " + "; :}
                        |     MINUS    {: RESULT = " - "; :}
                        |     TIMES    {: RESULT = " * "; :}
                        |     DIVIDE   {: RESULT = " / "; :}
;

boolean_expression      ::=   boolean_expression:be1 OR boolean_expression:be2   {:   RESULT = be1 + " || " + be2; :}
                        |     boolean_expression:be1 AND boolean_expression:be2  {:   RESULT = be1 + " && " + be2; :}
                        |     NOT boolean_expression:be                          {:   RESULT = "!" + be;           :}
                        |     LPAREN boolean_expression:be RPAREN                {:   RESULT = "( " + be + " )";   :}
                        |     boolean_final:bf                                   {:   RESULT = bf;                 :}
;

boolean_final           ::=   TRUE  {:   RESULT = "true";   :}
                        |     FALSE {:   RESULT = "false";  :}
;

assign_op               ::=   EQUALS
                        |     IS
;

entry                   ::=   THINK NEWLINE
                              /*optnl local_declaration:ldcl*/
                              optnl statement:s
                              optnl END
                              {:
                                 RESULT = "\n\tpublic static void think() {\n";
                                 //RESULT += ldcl;
                                 RESULT += s;
                                 RESULT += "\t}\n";
                              :}
;

constant_value          ::=   MAX_HASH      {: RESULT = "Double.MAX_VALUE";    :}
                        |     MIN_HASH		{: RESULT = "Double.MIN_VALUE";    :}
                        |     NOTHING_NOT	{: /* to do */ RESULT = "NOTHING"; :}
                        |     NOWHERE_AT	{: /* to do */ RESULT = "NOWHERE"; :}
;

optnl                   ::=   optnl NEWLINE
                        |
                              /* empty */
;

statement               ::=   call:cl optnl statement:stmt
                              {: RESULT = cl + stmt;  :}
                        |
                              local_declaration:ldcl optnl statement:stmt
                              {: RESULT = ldcl + stmt; :}
                        |
                              /* empty */
                              {: RESULT = ""; :}
;

function_call           ::=   function_name:fn
                              arguments_act:args
                              NEWLINE
                              {:
                                 // remove the final ,<space> : (arg1, arg2, ,<space>)
                                 args = args.trim();
                                 if (args.endsWith(",")) {
                         	    args = args.substring(0, args.length() - 1);
                                 }
                                 RESULT = "\t\t" + fn + "(" + args + ");\n";
                              :}
;

arguments_act           ::=   value:arg arguments_act:args
                              {:
                                 RESULT = arg + ", " + args;
                              :}

                        |     
                              /* empty */
                              {:
                                 RESULT = "";
                              :}
;

local_declaration       ::=   variable_name_local:vnl NEWLINE 
                              /*optnl local_declaration:dcl*/
                              {:
                                 RESULT = "\t\t" + vnl + ";\n"/* + dcl*/;
                              :}
                        |
                              field_access:fa assign_op value:val NEWLINE
                              /*optnl local_declaration:dcl*/
                              {:
                                 RESULT = "\t\t" + fa + " = " + val + ";\n" /*+ dcl*/;
                              :}
                        /*|*/
                              ///* empty */
                              /*{:
                                 RESULT = "";
                              :}*/
;

call                    ::=   SAY ANYTHING:a NEWLINE
                              {:
                                 RESULT = "\t\tSystem.out.println(\"" + a + "\");\n";
                              :}
                        |
                              function_call:fc
                              {:
                                 RESULT = fc;
                              :}
;

expr_list               ::=   expr_list expr_part 
                        |     expr_part
;

expr_part               ::=   expr:e
                              {:
                                 System.out.println(" = "+e+";");
                              :} 
                              SEMI
;

expr                    ::=   NUMBER:n               {: RESULT=n;                                        :}
                        |     expr:l PLUS expr:r     {: RESULT=new Integer(l.intValue() + r.intValue()); :}
                        |     expr:l TIMES expr:r    {: RESULT=new Integer(l.intValue() * r.intValue()); :}
                        |     LPAREN expr:e RPAREN   {: RESULT=e;                                        :}
;
