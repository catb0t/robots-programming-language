package Robot;

import java_cup.runtime.*;
import java.io.*;
import java.util.*;

/* value   ::= variable_name
         | base_value
         | boolean_expression
         | arithmetic_expression
         | constant_expression of variable_name
         | my constant_expression
         | constant_value */

parser code {:
	public static String  robotProgram;
	public static String  globalDeclarations;
	public static boolean bDebugFlag;

	/* stores a basic symbol table */
	public static HashMap<String, String> variableMap;
        public static Stack<String> currentScope;
	
	public static String temp;
	
	/* code related to symbol table: we have a very basic one coz java
	 is supposed to take care of the rest */
        /*
        public static boolean isNameDeclared(String name) {
	  return variableMap.containsKey(name);
	}

	public static boolean isNameDeclared(String name, String function) {
	  return isNameDeclared(function.concat(name));
	}
	*/
        public static boolean isDeclared(String name, String type) {
           String str = (String) variableMap.get(name);

           if (str != null && str.equals(type)) {
              System.out.println(name + " is ALREADY defined!"); 
              return true;
           } else {
              System.out.println(name + " is NOT defined!"); 
              return false;
           }
        }

        /*
        public static boolean isDeclared(String name, String type, String scope) {
           return isDeclared(scope.concat(name), type);
        }
        */
        public static boolean declareVariable(String name, String type) {
           if (!isDeclared(name, type)) {
              System.out.println("Declaring " + name); 
              variableMap.put(name, type);
              return true;
           } else {
              return false;
           }
        }

        public static boolean declareVariable(String name, String type, String scope) {
           return declareVariable(scope.concat(name), type);
        }

        public static void changeScope(String scope) {
           currentScope.push(scope);
           System.out.println("Changing scope: " + scope);
        }

        public static void endScope() {
           String scope = currentScope.pop();
           System.out.println("Ending scope: " + scope);
           // TODO: We should remove references of all variables that belong to the scope we're exiting 
           // In other words, once we're done in a block, variables that belong to that block
           // should be thrown out
        }


        public static void main(String args[]) throws Exception {
           bDebugFlag = true;
           try {
              robotProgram = "package Think;\n";
              globalDeclarations = "";
              variableMap = new HashMap<String, String>();
              currentScope = new Stack<String>();

              new parser(new Yylex(new BufferedReader(new FileReader(args[0])))).parse();

              // dump generated java code to file
              FileWriter fwTranslatedCode = new FileWriter(args[1], false);
              BufferedWriter bwTranslatedCode = new BufferedWriter(new FileWriter(args[1], false));
              robotProgram.replaceAll("\n", System.getProperty("line.separator"));
              bwTranslatedCode.write(robotProgram);
              bwTranslatedCode.close();

              //System.out.println("Translated Java code:\n" + robotProgram);
           } catch (Exception e) {
              System.out.println(e.getMessage());
           }
        }
:}

/* Terminals (tokens returned by the scanner) */
terminal         SEMI, PLUS, MINUS, TIMES, DIVIDE, LPAREN, RPAREN;
terminal         THINK, END, SAY, NEWLINE, EQUALS, IS, INSTRUCTION, WITH;
terminal         GIVES, NOTHING, MEANS, TRUE, FALSE, OR, AND, NOT;
terminal         MIN_HASH, MAX_HASH, NOTHING_NOT, NOWHERE_AT, OF, SELF;
terminal         IF, THEN, ELSE, DONE;
terminal Integer NUMBER;
terminal Double  NUMBER_EXPRESSION;
terminal String  NUMBER_PERCENTAGE;
terminal String  ANYTHING, INT_IDX;
terminal String  NUMBER_NAME, BOOLEAN_NAME, PERCENTAGE_NAME, LOCATION_NAME;
terminal String  ENEMY_NAME, RESOURCE_NAME, LIST_NAME, FUNCTION_NAME;
terminal String  NUMBER_LIST, BOOLEAN_LIST, PERCENTAGE_LIST, LOCATION_LIST;
terminal String  ENEMY_LIST, RESOURCE_LIST;
terminal         IS_LOWER_THAN, IS_STRICTLY_LOWER_THAN, IS_DIFFERENT_FROM;
terminal         IS_STRICTLY_GREATER_THAN, IS_GREATER_THAN, IS_EQUAL_TO;
terminal String  NUMBER_NAME_IDX;

/* Non-terminals */
non terminal         expr_list, expr_part;
non terminal Integer expr;
non terminal String  statement, entry, variable_name, program, return_value;
non terminal         optnl, assign_op;
non terminal String  function_name, function, functions, variable_name_local;
non terminal String  boolean_final, base_value, declaration, boolean_expression;
non terminal String  arithmetic_expression, arithmetic_operator, constant_value;
non terminal String  value, call, field_access, local_declaration;
non terminal String  field_name;
non terminal String  conditional, else_statement;
non terminal String  argument, arguments, arguments_act, function_call;
non terminal String  comparison_operator, boolean_exp_comp, index;
non terminal String  assignment;

/* Precedences: Follow Java conventions */
precedence right OF;

precedence left  OR;
precedence left  AND;

precedence left IS_DIFFERENT_FROM, IS_EQUAL_TO;

/* Do not split this line */
precedence nonassoc IS_STRICTLY_GREATER_THAN, IS_GREATER_THAN, IS_LOWER_THAN, IS_STRICTLY_LOWER_THAN;

precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;

precedence right NOT;

precedence left LPAREN, RPAREN;


/* The Grammar */
program         ::= optnl declaration:dcls
                    optnl entry:ent
                    optnl functions:funcs
                    optnl
                    {:
                       RESULT =  "\npublic class Robot {\n";
                       RESULT += dcls + ent + funcs;
                       RESULT += "\n}";
                       parser.robotProgram += RESULT;
                    :}
;

declaration     ::= variable_name:vn NEWLINE 
                    optnl declaration:dcl
                    {:
                       RESULT = vn + ";\n" + dcl;
                    :}
                 /*|
                    variable_name:vn assign_op value:val NEWLINE 
                    optnl declaration:dcl
                    {: 
                       RESULT = vn + " = " + val + ";\n" + dcl;
                    :}*/
                 |
                    variable_name:vn assign_op value:val NEWLINE
                    optnl declaration:dcl
                    {:
                       RESULT = vn + " = " + val + ";\n" + dcl;
                    :}
                 |
                    field_access:fa assign_op value:val NEWLINE
                    optnl declaration:dcl
                    {:
                       RESULT = fa + " = " + val + ";\n" + dcl;
                    :}
                 |
                    /* empty */
                    {:
                       RESULT = "";
                    :}
;

field_access    ::= field_name:fn OF value:fa
                    {:
                       RESULT = fa + "." + fn;
                    :}
                |   
                    index:idx OF value:fa
                    {:
                       RESULT = fa + "[" + idx + "]";
                    :}
                /*|   
                    variable_name:vn
                    {:
                       RESULT = vn;
                    :} 
                |   
                    SELF
                    {:
                       RESULT = "this";
                    :}*/
;

index           ::=  NUMBER_NAME_IDX:nnidx
                     {: nnidx.substring(0, nnidx.length() - 3); :}
                |
                     INT_IDX:nidx
                     {: nidx.substring(0, nidx.length() - 2);   :}
;

field_name      ::=  NUMBER_NAME:nn
                     {:
                       RESULT = nn.substring(0, nn.length() - 1);
                     :}
                 |
                     NUMBER_LIST:nl
                     {:
                       RESULT = nl.substring(0, nl.length() - 4);
                     :}
                 |
                    LIST_NAME:ln
                    {:
                       RESULT = ln.substring(0, ln.length() - 3);
                    :}
                |
                    BOOLEAN_NAME:bn
                    {:
                       RESULT = bn.substring(0, bn.length() - 1);
                    :}
                |
                    PERCENTAGE_NAME:pn
                    {:
                       RESULT = pn.substring(0, pn.length() - 1);
                    :}

                |
                    LOCATION_NAME:ln
                    {:
                       RESULT = ln.substring(0, ln.length() - 1);
                    :}
                |
                    LOCATION_LIST:ll
                    {:
                       RESULT = ll.substring(0, ll.length() - 4);
                    :}
                |
                    ENEMY_NAME:en
                    {:
                       RESULT = en.substring(0, en.length() - 1);
                    :}
                |
                    RESOURCE_NAME:rn
                    {:
                       RESULT = rn.substring(0, rn.length() - 1);
                    :}
;

// TODO: We don't need to call isDeclared, it's already being called in declare variable
// See local_variable to see shorter usage
// Also, I was thinking that we can add a Java Enum to enumerate our types and enter
// associated information like the corresponding Java type, postfix, etc.  Would be much
// cleaner than typing those things every time, I think
variable_name   ::= NUMBER_NAME:nn
                    {:
                       parser.temp = nn.substring(0, nn.length() - 1);
                       if (!parser.isDeclared(parser.temp, "#")) {
                          RESULT = "\tpublic double " + parser.temp;
                          parser.declareVariable(parser.temp, "#");
                       } else {
                          RESULT = parser.temp;
                       }
                    :}
                 |
                    LIST_NAME:ln
                    {:
                       parser.temp = ln.substring(0, ln.length() - 3);
                       if (!parser.isDeclared(parser.temp, "...")) {
                          RESULT = "\tpublic List " + parser.temp;
                          parser.declareVariable(parser.temp, "...");
                       } else {
                          RESULT = parser.temp;
                       }
                    :}
                |
                    BOOLEAN_NAME:bn
                    {:
                       parser.temp = bn.substring(0, bn.length() - 1);
                       if (!parser.isDeclared(parser.temp, "?")) {
                          RESULT = "\tpublic boolean " + parser.temp;
                          parser.declareVariable(parser.temp, "?");
                       } else {
                          RESULT = parser.temp;
                       }
                    :}
                |
                    PERCENTAGE_NAME:pn
                    {:
                       parser.temp = pn.substring(0, pn.length() - 1);
                       if (!parser.isDeclared(parser.temp, "%")) {
                          RESULT = "\tpublic Percentage " + parser.temp;
                          parser.declareVariable(parser.temp, "%");
                       } else {
                          RESULT = parser.temp;
                       }
                    :}

                |
                    LOCATION_NAME:ln
                    {:
                       parser.temp = ln.substring(0, ln.length() - 1);
                       if (!parser.isDeclared(parser.temp, "@")) {
                          RESULT = "\tpublic Location " + parser.temp;
                          parser.declareVariable(parser.temp, "@");
                       } else {
                          RESULT = parser.temp;
                       }
                    :}
                |
                    ENEMY_NAME:en
                    {:
                       parser.temp = en.substring(0, en.length() - 1);
                       if (!parser.isDeclared(parser.temp, "!")) {
                          RESULT = "\tpublic Enemy " + parser.temp;
                          parser.declareVariable(parser.temp, "!");
                       } else {
                          RESULT = parser.temp;
                       }
                    :}
                |
                    RESOURCE_NAME:rn
                    {:
                       parser.temp = rn.substring(0, rn.length() - 1);
                       if (!parser.isDeclared(parser.temp, "$")) {
                          RESULT = "\tpublic Resource " + parser.temp;
                          parser.declareVariable(parser.temp, "$");
                       } else {
                          RESULT = parser.temp;
                       }
                    :}
;

functions       ::=   function:fn optnl
                      functions:fns          {: RESULT = fn + fns; :}
                |
                      /* empty */            {: RESULT = ""; :}
;

function        ::=   INSTRUCTION function_name:fn {: parser.changeScope(fn); :}
                      WITH arguments:arg MEANS NEWLINE optnl
                      statement:stat optnl
                      GIVES return_value:rv NEWLINE
                      {:
                         // remove the final ,<space> : (arg1, arg2, ,<space>)
                         arg = arg.trim();
                         if(arg.endsWith(",")) {
                         	arg = arg.substring(0, arg.length() - 1);
                         }
                         RESULT = "\n\tpublic static " + rv + " " + fn + "(" + arg + ")";
                         RESULT += " {\n" + "\n" + stat + "\n\t}";
                         parser.endScope();
                      :}
;

function_name   ::=   FUNCTION_NAME:fn       {: RESULT = fn;   :}
;

return_value    ::=   value:val              {: RESULT = val;    :}
                |
                      NOTHING                {: RESULT = "void"; :}
;

arguments        ::=   variable_name_local:arg arguments:args 
                       {:
                          RESULT = arg + ", " + args;
                       :}
                |
                       /* empty */
                       {:
                          RESULT = "";
                       :}
                      
;

variable_name_local  ::=  
                    NUMBER_NAME:nn
                    {:
                       parser.temp = nn.substring(0, nn.length() - 1);
                       
                       if (parser.declareVariable(parser.temp, "#", parser.currentScope.peek())) {
                          RESULT = "double ";
                       } else {
                          RESULT = "";
                       }
                       
                       RESULT += parser.temp;
                    :}
                 |
                    NUMBER_LIST:nl
                    {:
                       parser.temp = nl.substring(0, nl.length() - 4);
                       
                       if (parser.declareVariable(parser.temp, "#...", parser.currentScope.peek())) {
                          RESULT = "double[] ";
                       } else {
                          RESULT = "";
                       }
                       
                       RESULT += parser.temp;
                    :}
                 |
                    LIST_NAME:ln
                    {:
                       parser.temp = ln.substring(0, ln.length() - 3);
                       
                       if (parser.declareVariable(parser.temp, "...", parser.currentScope.peek())) {
                          RESULT = "List ";
                       } else {
                          RESULT = "";
                       }
                       
                       RESULT += parser.temp;
                    :}
                |
                    BOOLEAN_NAME:bn
                    {:
                       parser.temp = bn.substring(0, bn.length() - 1);
                       
                       if (parser.declareVariable(parser.temp, "?", parser.currentScope.peek())) {
                          RESULT = "boolean ";
                       } else {
                          RESULT = "";
                       }
                       
                       RESULT += parser.temp;
                    :}
                |
                    PERCENTAGE_NAME:pn
                    {:
                       parser.temp = pn.substring(0, pn.length() - 1);
                       
                       if (parser.declareVariable(parser.temp, "%", parser.currentScope.peek())) {
                          RESULT = "Percentage ";
                       } else {
                          RESULT = "";
                       }
                       
                       RESULT += parser.temp;
                    :}

                |
                    LOCATION_NAME:ln
                    {:
                       parser.temp = ln.substring(0, ln.length() - 1);
                       
                       if (parser.declareVariable(parser.temp, "@", parser.currentScope.peek())) {
                          RESULT = "Location ";
                       } else {
                          RESULT = "";
                       }
                       
                       RESULT += parser.temp;
                    :}
                |
                    LOCATION_LIST:ll
                    {:
                       parser.temp = ll.substring(0, ll.length() - 1);
                       
                       if (parser.declareVariable(parser.temp, "@...", parser.currentScope.peek())) {
                          RESULT = "Location[] ";
                       } else {
                          RESULT = "";
                       }
                       
                       RESULT += parser.temp;
                    :}
                |
                    ENEMY_NAME:en
                    {:
                       parser.temp = en.substring(0, en.length() - 1);
                       
                       if (parser.declareVariable(parser.temp, "!", parser.currentScope.peek())) {
                          RESULT = "Enemy ";
                       } else {
                          RESULT = "";
                       }
                       
                       RESULT += parser.temp;
                    :}
                |
                    RESOURCE_NAME:rn
                    {:
                       parser.temp = rn.substring(0, rn.length() - 1);
                       
                       if (parser.declareVariable(parser.temp, "$", parser.currentScope.peek())) {
                          RESULT = "Resource ";
                       } else {
                          RESULT = "";
                       }
                       
                       RESULT += parser.temp;
                    :}
;

value           ::=   boolean_expression:be  {:   RESULT = be;     :}
                |
                      SELF                   {:   RESULT = "this"; :}
;

base_value      ::=   boolean_expression:be    {:   RESULT = be; :}
                |
                      arithmetic_expression:ae {:   RESULT = ae; :}
;

arithmetic_expression   ::=   arithmetic_expression:ae1 arithmetic_operator:ao arithmetic_expression:ae2
                              {:
                                 RESULT = ae1 + ao + ae2;
                              :}
                        |
                              LPAREN arithmetic_expression:ae RPAREN
                              {:
                                 RESULT = "( " + ae + " )";
                              :}
                        |
                              NUMBER_EXPRESSION:ne
                              {:
                                 RESULT = ne.toString();
                              :}
                        |
                              NUMBER_PERCENTAGE:pe
                              {:
                                 RESULT = "new Percentage(" + pe.substring(0, pe.length() - 1) + ")";
                              :}
;

arithmetic_operator     ::=   PLUS     {: RESULT = " + "; :}
                        |     MINUS    {: RESULT = " - "; :}
                        |     TIMES    {: RESULT = " * "; :}
                        |     DIVIDE   {: RESULT = " / "; :}
;

boolean_expression      ::=   boolean_expression:be1 OR boolean_expression:be2
                              {:   RESULT = be1 + " || " + be2; :}
                        |     
                              boolean_expression:be1 AND boolean_expression:be2
                              {:   RESULT = be1 + " && " + be2; :}
                        |     
                              NOT boolean_expression:be
                              {:   RESULT = "!" + be;           :}
                        |     
                              LPAREN boolean_expression:be RPAREN
                              {:   RESULT = "( " + be + " )";   :}
                        |     
                              boolean_final:bf
                              {:   RESULT = bf;                 :}
                        |     
                              boolean_exp_comp:bec
                              {:  RESULT = bec;  :}
                        |     
                              boolean_exp_comp:bec1 comparison_operator:co
                              boolean_exp_comp:bec2
                              {:  RESULT = bec1 + co + bec2;  :}
;
                      
boolean_exp_comp        ::=   field_name:fn   
                              {:   RESULT = fn; :}
                        |
                              arithmetic_expression:ae 
                              {:   RESULT = ae; :}
                        |
                              constant_value:cv
                              {: RESULT = cv;   :}
                        |
                              function_call:fc
                              {:   RESULT = fc; :}
                        |
                              field_access:fa
                              {:   RESULT = fa; :}
;

comparison_operator     ::=   IS_EQUAL_TO
                        |     IS_LOWER_THAN
                        |     IS_STRICTLY_LOWER_THAN
                        |     IS_STRICTLY_GREATER_THAN
                        |     IS_GREATER_THAN
                        |     IS_DIFFERENT_FROM
;

boolean_final           ::=   TRUE  {:   RESULT = "true";   :}
                        |     FALSE {:   RESULT = "false";  :}
;

assign_op               ::=   EQUALS
                        |     IS
;

entry                   ::=   THINK {: parser.changeScope("think"); :} NEWLINE
                              optnl statement:s
                              optnl END
                              {:
                                 RESULT = "\n\tpublic static void think() {\n";
                                 RESULT += s;
                                 RESULT += "\t}\n";
                                 parser.endScope();
                              :}
;

constant_value          ::=   MAX_HASH      {: RESULT = "Double.MAX_VALUE";    :}
                        |     MIN_HASH		{: RESULT = "Double.MIN_VALUE";    :}
                        |     NOTHING_NOT	{: /* to do */ RESULT = "NOTHING"; :}
                        |     NOWHERE_AT	{: /* to do */ RESULT = "NOWHERE"; :}
;

optnl                   ::=   optnl NEWLINE
                        |
                              /* empty */
;

statement               ::=   call:cl optnl statement:stmt
                              {: RESULT = cl + stmt;  :}
                        |
                              local_declaration:ldcl optnl statement:stmt
                              {: RESULT = ldcl + stmt; :}
                        |
                              conditional:cond optnl statement:stmt
                              {: RESULT = cond + stmt; :}
                        |
                              assignment:ass optnl statement:stmt
                              {: RESULT = ass + stmt;  :}
                        |
                              /* empty */
                              {: RESULT = ""; :}
;

assignment              ::=   variable_name_local:vnl assign_op value:val NEWLINE
                              {:
                                 RESULT = "\t\t" + vnl + " = " + val + ";\n"; 
                              :}
                        |
                              field_access:fa assign_op value:val NEWLINE
                              {: 
                                 RESULT = "\t\t" + fa + " = " + val + ";\n"; 
                              :}
;

conditional             ::=   IF boolean_expression:be THEN NEWLINE
                              statement:stmt NEWLINE optnl 
                              else_statement:es optnl DONE NEWLINE
                              {:
                                 RESULT =  "\t\tif(" + be + "){\n";
                                 RESULT += stmt;
                                 RESULT += es;
                                 RESULT += "\n\t\t}\n"; 
                              :}
;

else_statement          ::=   ELSE NEWLINE statement:stmt NEWLINE
                              {: 
                                 RESULT =  "\t\telse {\n" + stmt;
                              :}
                        |     
                              /* empty */
                              {: RESULT = ""; :}
;

function_call           ::=   function_name:fn
                              arguments_act:args
                              NEWLINE
                              {:
                                 // remove the final ,<space> : (arg1, arg2,<space>)
                                 args = args.trim();
                                 if (args.endsWith(",")) {
                         	    args = args.substring(0, args.length() - 1);
                                 }
                                 RESULT = "\t\t" + fn + "(" + args + ");\n";
                              :}
;

arguments_act           ::=   value:arg arguments_act:args
                              {:
                                 RESULT = arg + ", " + args;
                              :}

                        |     
                              /* empty */
                              {:
                                 RESULT = "";
                              :}
;

local_declaration       ::=   variable_name_local:vnl NEWLINE 
                              {:
                                 RESULT = "\t\t" + vnl + ";\n"/* + dcl*/;
                              :}
                        /*|
                              variable_name_local:vnl assign_op value:val NEWLINE
                              {:
                                 RESULT = "\t\t" + vnl + " = " + val + ";\n";
                              :}
                        |
                              field_access:fa assign_op value:val NEWLINE
                              {:
                                 RESULT = "\t\t" + fa + " = " + val + ";\n";
                              :}*/
;

call                    ::=   SAY ANYTHING:a NEWLINE
                              {:
                                 RESULT = "\t\tSystem.out.println(\"" + a + "\");\n";
                              :}
                        |
                              function_call:fc
                              {:
                                 RESULT = fc;
                              :}
;

expr_list               ::=   expr_list expr_part 
                        |     expr_part
;

expr_part               ::=   expr:e
                              {:
                                 System.out.println(" = "+e+";");
                              :}
                              SEMI
;

expr                    ::=   NUMBER:n               {: RESULT=n;                                        :}
                        |     expr:l PLUS expr:r     {: RESULT=new Integer(l.intValue() + r.intValue()); :}
                        |     expr:l TIMES expr:r    {: RESULT=new Integer(l.intValue() * r.intValue()); :}
                        |     LPAREN expr:e RPAREN   {: RESULT=e;                                        :}
;
