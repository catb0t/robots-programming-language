package Robot;

import java_cup.runtime.*;
import java.io.*;
import java.util.*;

/* value   ::= variable_name
         | base_value
         | boolean_expression
         | arithmetic_expression
         | constant_expression of variable_name
         | my constant_expression
         | constant_value */

parser code {:
	public static String  robotProgram;
	public static String  globalDeclarations;
	public static boolean bDebugFlag;

	/* stores a basic symbol table */
	public static HashMap<String, String> variableMap;
        public static Stack<String> currentScope;
	
	public static String temp;
	
	/* code related to symbol table: we have a very basic one coz java
	 is supposed to take care of the rest */
        /*
        public static boolean isNameDeclared(String name) {
	  return variableMap.containsKey(name);
	}

	public static boolean isNameDeclared(String name, String function) {
	  return isNameDeclared(function.concat(name));
	}
	*/
        public static boolean isDeclared(String name, String type) {
           String str = (String) variableMap.get(name);

           if (str != null && str.equals(type)) {
              System.out.println(name + " is ALREADY defined!"); 
              return true;
           } else {
              System.out.println(name + " is NOT defined!"); 
              return false;
           }
        }

        /*
        public static boolean isDeclared(String name, String type, String scope) {
           return isDeclared(scope.concat(name), type);
        }
        */
        public static boolean declareVariable(String name, String type) {
           if (!isDeclared(name, type)) {
              System.out.println("Declaring " + name); 
              variableMap.put(name, type);
              return true;
           } else {
              return false;
           }
        }

        public static boolean declareVariable(String name, String type, String scope) {
           return declareVariable(scope.concat(name), type);
        }

        public static void changeScope(String scope) {
           currentScope.push(scope);
           System.out.println("Changing scope: " + scope);
        }

        public static void endScope() {
           String scope = currentScope.pop();
           System.out.println("Ending scope: " + scope);
           // TODO: We should remove references of all variables that belong to the scope we're exiting 
           // In other words, once we're done in a block, variables that belong to that block
           // should be thrown out
        }

        public static String getIndent() {
           String indent = "";

           for(int i=0; i <= currentScope.size(); i++) {
              indent += "\t";
           }
           System.out.println("INDENT: " + currentScope.size() + " " + indent);
           return indent;
        }


        public static void main(String args[]) throws Exception {
           bDebugFlag = true;
           try {
              robotProgram = "package Think;\n";
              globalDeclarations = "";
              variableMap = new HashMap<String, String>();
              currentScope = new Stack<String>();

              new parser(new Yylex(new BufferedReader(new FileReader(args[0])))).debug_parse();

              // dump generated java code to file
              FileWriter fwTranslatedCode = new FileWriter(args[1], false);
              BufferedWriter bwTranslatedCode = new BufferedWriter(new FileWriter(args[1], false));
              robotProgram.replaceAll("\n", System.getProperty("line.separator"));
              bwTranslatedCode.write(robotProgram);
              bwTranslatedCode.close();

              //System.out.println("Translated Java code:\n" + robotProgram);
           } catch (Exception e) {
              System.out.println(e.getMessage());
           }
        }
:}

/* Terminals (tokens returned by the scanner) */
terminal         SEMI, PLUS, MINUS, TIMES, DIVIDE, LPAREN, RPAREN;
terminal         THINK, END, SAY, NEWLINE, EQUALS, IS, INSTRUCTION, WITH;
terminal         GIVES, NOTHING, MEANS, TRUE, FALSE, OR, AND, NOT;
terminal         MIN_HASH, MAX_HASH, NOTHING_NOT, NOWHERE_AT, OF, SELF;
terminal         IF, THEN, ELSE, DONE;
terminal Integer NUMBER;
terminal Double  NUMBER_EXPRESSION;
terminal String  NUMBER_PERCENTAGE;
terminal String  ANYTHING, INT_IDX;
terminal         IS_LOWER_THAN, IS_STRICTLY_LOWER_THAN, IS_DIFFERENT_FROM;
terminal         IS_STRICTLY_GREATER_THAN, IS_GREATER_THAN, IS_EQUAL_TO;
terminal String  NUMBER_NAME_IDX;
terminal String  FUNCTION_NAME;
terminal RobotVar VARIABLE;

/* Non-terminals */
non terminal         expr_list, expr_part;
non terminal Integer expr;
non terminal String  statement, entry, variable_name, program, return_value, block;
non terminal         optnl, assign_op;
non terminal String  function_name, function, functions, variable_name_local;
non terminal String  boolean_final, base_value, declaration, boolean_expression, boolean_component;
non terminal String  any_expr;
non terminal String  arithmetic_expression, arithmetic_operator, constant_value;
non terminal String  call, field_access, local_declaration;
non terminal String  field_name;
non terminal String  conditional, else_statement;
non terminal String  argument, arguments, arguments_act, function_call;
non terminal String  comparison_operator, index;
non terminal String  assignment;

/* Precedences: Follow Java conventions */
precedence right OF;

precedence left  OR;
precedence left  AND;

precedence left IS_DIFFERENT_FROM, IS_EQUAL_TO;

/* Do not split this line */
precedence nonassoc IS_STRICTLY_GREATER_THAN, IS_GREATER_THAN, IS_LOWER_THAN, IS_STRICTLY_LOWER_THAN;

precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;

precedence right NOT;

precedence left LPAREN, RPAREN;


/* The Grammar */
program         ::= optnl declaration:dcls
                    optnl entry:ent
                    optnl functions:funcs
                    optnl
                    {:
                       RESULT =  "\npublic class Robot {\n";
                       RESULT += dcls + ent + funcs;
                       RESULT += "\n}\n";
                       parser.robotProgram += RESULT;
                    :}
;

declaration     ::= variable_name:vn NEWLINE 
                    optnl declaration:dcl
                    {:
                       RESULT = vn + ";\n" + dcl;
                    :}
                 /*|
                    variable_name:vn assign_op value:val NEWLINE 
                    optnl declaration:dcl
                    {: 
                       RESULT = vn + " = " + val + ";\n" + dcl;
                    :}*/
                 |
                    variable_name:vn assign_op any_expr:ex NEWLINE
                    optnl declaration:dcl
                    {:
                       RESULT = vn + " = " + ex + ";\n" + dcl;
                    :}
                 |
                    field_access:fa assign_op any_expr:ex NEWLINE
                    optnl declaration:dcl
                    {:
                       RESULT = fa + " = " + ex + ";\n" + dcl;
                    :}
                 |
                    /* empty */
                    {:
                       RESULT = "";
                    :}
;

field_access    ::= field_name:fn OF base_value:fa
                    {:
                       RESULT = fa + "." + fn;
                    :}
                |   
                    index:idx OF base_value:fa
                    {:
                       RESULT = fa + "[" + idx + "]";
                    :}
                /*|   
                    variable_name:vn
                    {:
                       RESULT = vn;
                    :} 
                |   
                    SELF
                    {:
                       RESULT = "this";
                    :}*/
;

index           ::=  NUMBER_NAME_IDX:nnidx
                     {: nnidx.substring(0, nnidx.length() - 3); :}
                |
                     INT_IDX:nidx
                     {: nidx.substring(0, nidx.length() - 2);   :}
;

field_name      ::=  VARIABLE:v
                     {:
                       RESULT = v.name();
                     :}
;

// TODO: We don't need to call isDeclared, it's already being called in declare variable
// See local_variable to see shorter usage
// Also, I was thinking that we can add a Java Enum to enumerate our types and enter
// associated information like the corresponding Java type, postfix, etc.  Would be much
// cleaner than typing those things every time, I think
variable_name   ::= VARIABLE:v
                    {:
                       if (parser.declareVariable(v.name(), v.type().postFix())) {
                          RESULT = "\tpublic " + v.type().javaType() + " "; 
                       } else {
                          RESULT = ""; 
                       }

                       RESULT += v.name();
                    :}
;

functions       ::=   function:fn optnl
                      functions:fns          {: RESULT = fn + fns; :}
                |
                      /* empty */            {: RESULT = ""; :}
;

function        ::=   INSTRUCTION function_name:fn {: parser.changeScope(fn); :}
                      WITH arguments:arg MEANS NEWLINE optnl
                      block:b optnl
                      GIVES return_value:rv NEWLINE
                      {:
                         // remove the final ,<space> : (arg1, arg2, ,<space>)
                         arg = arg.trim();
                         if(arg.endsWith(",")) {
                         	arg = arg.substring(0, arg.length() - 1);
                         }
                         RESULT = "\n\tpublic static " + rv + " " + fn + "(" + arg + ")";
                         RESULT += " {\n" + "\n" + b + "\n\t}";
                         parser.endScope();
                      :}
;

function_name   ::=   FUNCTION_NAME:fn       {: RESULT = fn;   :}
;

return_value    ::=   VARIABLE:v             {: RESULT = v.type().javaType(); :}
                |
                      NOTHING                {: RESULT = "void"; :}
;

arguments        ::=   variable_name_local:arg arguments:args 
                       {:
                          RESULT = arg + ", " + args;
                       :}
                |
                       /* empty */
                       {:
                          RESULT = "";
                       :}
                      
;

variable_name_local  ::=  VARIABLE:v
                          {:
                             if (parser.declareVariable(v.name(), v.type().postFix(), parser.currentScope.peek())) {
                                RESULT = v.type().javaType() + " ";
                             } else {
                                RESULT = "";
                             }
                             
                             RESULT += v.name();
                          :}
;

base_value      ::=   field_name:fn            {:   RESULT = fn;     :}
                |
                      constant_value:cv        {:   RESULT = cv;     :}
                |
                      function_call:fc         {:   RESULT = fc;     :}
                |
                      field_access:fa          {:   RESULT = fa;     :}
                |
                      SELF                     {:   RESULT = "this"; :}
;

any_expr        ::=   boolean_expression:be    {:   RESULT = be; :}
                |
                      arithmetic_expression:ae {:   RESULT = ae; :}
;

arithmetic_expression   ::=   arithmetic_expression:ae1 arithmetic_operator:ao arithmetic_expression:ae2
                              {:
                                 RESULT = ae1 + ao + ae2;
                              :}
                        |
                              LPAREN arithmetic_expression:ae RPAREN
                              {:
                                 RESULT = "( " + ae + " )";
                              :}
                        |
                              NUMBER_EXPRESSION:ne
                              {:
                                 RESULT = ne.toString();
                              :}
                        |
                              NUMBER_PERCENTAGE:pe
                              {:
                                 RESULT = "new Percentage(" + pe.substring(0, pe.length() - 1) + ")";
                              :}
;

arithmetic_operator     ::=   PLUS     {: RESULT = " + "; :}
                        |     MINUS    {: RESULT = " - "; :}
                        |     TIMES    {: RESULT = " * "; :}
                        |     DIVIDE   {: RESULT = " / "; :}
;

boolean_expression      ::=   boolean_expression:be1 OR boolean_expression:be2
                              {:   RESULT = be1 + " || " + be2; :}
                        |     
                              boolean_expression:be1 AND boolean_expression:be2
                              {:   RESULT = be1 + " && " + be2; :}
                        |     
                              NOT boolean_expression:be
                              {:   RESULT = "!" + be;           :}
                        |     
                              LPAREN boolean_expression:be RPAREN
                              {:   RESULT = "( " + be + " )";   :}
                        |     
                              boolean_final:bf
                              {:   RESULT = bf;                 :}
                        |     
                              boolean_component:bec
                              {:  RESULT = bec;  :}
                        |     
                              boolean_component:bec1 comparison_operator:co
                              boolean_component:bec2
                              {:  RESULT = bec1 + co + bec2;  :}
;

boolean_component       ::=   base_value:bv {: RESULT = bv; :}
;
                      
comparison_operator     ::=   IS_EQUAL_TO
                        |     IS_LOWER_THAN
                        |     IS_STRICTLY_LOWER_THAN
                        |     IS_STRICTLY_GREATER_THAN
                        |     IS_GREATER_THAN
                        |     IS_DIFFERENT_FROM
;

boolean_final           ::=   TRUE  {:   RESULT = "true";   :}
                        |     FALSE {:   RESULT = "false";  :}
;

assign_op               ::=   EQUALS
                        |     IS
;

entry                   ::=   THINK {: parser.changeScope("think"); :} NEWLINE
                              optnl block:b
                              optnl END
                              {:
                                 RESULT =  "\n";
                                 RESULT += "\tpublic static void think() {\n";
                                 RESULT += "\n";
                                 RESULT += b;
                                 RESULT += "\n";
                                 RESULT += "\t}\n";
                                 RESULT += "\n";
                                 parser.endScope();
                              :}
;

constant_value          ::=   MAX_HASH          {: RESULT = "Double.MAX_VALUE";    :}
                        |     MIN_HASH		{: RESULT = "Double.MIN_VALUE";    :}
                        |     NOTHING_NOT	{: /* to do */ RESULT = "NOTHING"; :}
                        |     NOWHERE_AT	{: /* to do */ RESULT = "NOWHERE"; :}
;

optnl                   ::=   optnl NEWLINE
                        |
                              /* empty */
;

statement               ::=   call:cl                {: RESULT = cl;   :}
                        |     local_declaration:ldcl {: RESULT = ldcl; :}
                        |     conditional:cond       {: RESULT = cond; :}
                        |     assignment:ass         {: RESULT = ass;  :}
;

block                   ::=   statement:s {: RESULT = parser.getIndent() + s + ";\n"; :}
                              optnl
                              block:b     {: RESULT += b; :}
                        |
                              /* empty */
                              {: RESULT = ""; :}
;


assignment              ::=   variable_name_local:vnl assign_op any_expr:ex NEWLINE
                              {:
                                 RESULT = vnl + " = " + ex; 
                              :}
                        |
                              field_access:fa assign_op any_expr:ex NEWLINE
                              {: 
                                 RESULT = fa + " = " + ex; 
                              :}
;

conditional             ::=   IF boolean_expression:be THEN NEWLINE
                              block:b NEWLINE optnl 
                              else_statement:es optnl DONE NEWLINE
                              {:
                                 RESULT =  "\t\tif(" + be + "){\n";
                                 RESULT += b;
                                 RESULT += es;
                                 RESULT += "\n\t\t}\n"; 
                              :}
;

else_statement          ::=   ELSE NEWLINE block:b NEWLINE
                              {: 
                                 RESULT =  "\t\telse {\n" + b;
                              :}
                        |     
                              /* empty */
                              {: RESULT = ""; :}
;

function_call           ::=   function_name:fn
                              arguments_act:args
                              NEWLINE
                              {:
                                 // remove the final ,<space> : (arg1, arg2,<space>)
                                 args = args.trim();
                                 if (args.endsWith(",")) {
                         	    args = args.substring(0, args.length() - 1);
                                 }
                                 RESULT = fn + "(" + args + ")";
                              :}
;

arguments_act           ::=   any_expr:arg arguments_act:args
                              {:
                                 RESULT = arg + ", " + args;
                              :}

                        |     
                              /* empty */
                              {:
                                 RESULT = "";
                              :}
;

local_declaration       ::=   variable_name_local:vnl NEWLINE 
                              {:
                                 RESULT = vnl /* + dcl*/;
                              :}
                        /*|
                              variable_name_local:vnl assign_op value:val NEWLINE
                              {:
                                 RESULT = "\t\t" + vnl + " = " + val + ";\n";
                              :}
                        |
                              field_access:fa assign_op value:val NEWLINE
                              {:
                                 RESULT = "\t\t" + fa + " = " + val + ";\n";
                              :}*/
;

call                    ::=   SAY ANYTHING:a NEWLINE
                              {:
                                 RESULT = "System.out.println(\"" + a + "\")";
                              :}
                        |
                              function_call:fc
                              {:
                                 RESULT = fc;
                              :}
;

expr_list               ::=   expr_list expr_part 
                        |     expr_part
;

expr_part               ::=   expr:e
                              {:
                                 System.out.println(" = "+e+";");
                              :}
                              SEMI
;

expr                    ::=   NUMBER:n               {: RESULT=n;                                        :}
                        |     expr:l PLUS expr:r     {: RESULT=new Integer(l.intValue() + r.intValue()); :}
                        |     expr:l TIMES expr:r    {: RESULT=new Integer(l.intValue() * r.intValue()); :}
                        |     LPAREN expr:e RPAREN   {: RESULT=e;                                        :}
;
